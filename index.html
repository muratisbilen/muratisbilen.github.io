<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exponential Sum Plotter</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            margin: 2rem;
            background-color: #f4f4f9;
            color: #333;
        }
        .container {
            width: 100%;
            max-width: 800px;
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.1);
            text-align: center;
        }
        h1 {
            color: #0056b3;
        }
        .input-group {
            display: flex;
            gap: 10px;
            margin: 1.5rem 0;
        }
        #text-input {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 1rem;
        }
        button {
            padding: 10px 20px;
            border: none;
            background-color: #007bff;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: background-color 0.2s, transform 0.1s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:active {
            transform: scale(0.98);
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #plot-container {
            margin-top: 1rem;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #fafafa;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }
        #plot-canvas {
            max-width: 100%;
            max-height: 100%;
        }
        .status-bar {
            margin-top: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 24px;
        }
        #status-label {
            color: #555;
            text-align: left;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Exponential Sum Plotter</h1>
        <p>Enter any string to generate a unique plot based on its cryptographic hash.</p>

        <div class="input-group">
            <input type="text" id="text-input" placeholder="e.g., İstanbul, Türkiye, Hello World">
            <button id="generate-button">Generate Plot</button>
        </div>

        <div id="plot-container">
            <canvas id="plot-canvas" width="600" height="600"></canvas>
        </div>

        <div class="status-bar">
            <span id="status-label">Status: Ready</span>
            <button id="download-button" disabled>Download Image</button>
        </div>
    </div>

    <script>
        // --- Get references to HTML elements ---
        const textInput = document.getElementById('text-input');
        const generateButton = document.getElementById('generate-button');
        const downloadButton = document.getElementById('download-button');
        const statusLabel = document.getElementById('status-label');
        const canvas = document.getElementById('plot-canvas');
        const ctx = canvas.getContext('2d');

        // --- Core Mathematical Logic in JavaScript ---

        function gcd(a, b) {
            return b === 0 ? a : gcd(b, a % b);
        }

        function lcm(a, b) {
            if (a === 0 || b === 0) return 0;
            return Math.abs(a * b) / gcd(a, b);
        }

        /**
         * Generates a date from a string using SHA-256 hash. (Async function)
         */
        async function stringToDate(inputString) {
            if (!inputString) return null;

            // 1. Encode string to bytes
            const encoder = new TextEncoder();
            const data = encoder.encode(inputString.toUpperCase());
            
            // 2. Compute SHA-256 hash using the browser's built-in crypto API
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            
            // 3. Convert the hash buffer to a hexadecimal string
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hexDigest = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

            // 4. Derive date components from the end of the hash string
            const yearPart = parseInt(hexDigest.slice(-4), 16) % 8030;
            const y = yearPart + 1970;

            const monthPart = parseInt(hexDigest.slice(-6, -4), 16);
            const m = (monthPart % 12) + 1;

            const dayPart = parseInt(hexDigest.slice(-8, -6), 16);
            const d = (dayPart % 28) + 1;

            return { m, d, y };
        }

        /**
         * Calculates the exponential sum and returns an array of points.
         */
        function calculateExponentialSum(m, d, y) {
            const lcm_md = lcm(m, d);
            const lcm_mdy = lcm(lcm_md, y);
            const N = 2 * lcm_mdy + 1;

            if (N > 15000000) { // Safety limit to prevent browser from freezing
                throw new Error(`Calculation aborted: N is too large (${N.toLocaleString()}). The date combination is too complex.`);
            }

            const zPoints = [];
            let currentZ = { re: 0, im: 0 }; // Represents a complex number

            for (let n = 0; n <= N; n++) {
                const f = n / m + (n ** 2) / d + (n ** 3) / y;
                const theta = 2 * Math.PI * f;

                // Euler's formula: e^(i*theta) = cos(theta) + i*sin(theta)
                const expPoint = { re: Math.cos(theta), im: Math.sin(theta) };

                // Cumulatively sum the points
                currentZ.re += expPoint.re;
                currentZ.im += expPoint.im;

                zPoints.push({ re: currentZ.re, im: currentZ.im });
            }
            return zPoints;
        }

        /**
         * Renders the points on the HTML canvas.
         */
        function drawPlot(points) {
            // 1. Find the data boundaries to scale the plot correctly
            let minRe = Infinity, maxRe = -Infinity, minIm = Infinity, maxIm = -Infinity;
            for (const p of points) {
                if (p.re < minRe) minRe = p.re;
                if (p.re > maxRe) maxRe = p.re;
                if (p.im < minIm) minIm = p.im;
                if (p.im > maxIm) maxIm = p.im;
            }

            // 2. Determine scale and offset to center the plot and maintain aspect ratio
            const dataWidth = maxRe - minRe;
            const dataHeight = maxIm - minIm;
            
            const scale = Math.min(canvas.width / dataWidth, canvas.height / dataHeight) * 0.9; // 90% padding
            
            const offsetX = (canvas.width - dataWidth * scale) / 2 - minRe * scale;
            const offsetY = (canvas.height + dataHeight * scale) / 2 + minIm * scale;

            // 3. Clear and draw the plot
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#003366';

            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const canvasX = p.re * scale + offsetX;
                const canvasY = canvas.height - (p.im * scale + offsetY - dataHeight*scale); // Flip Y-axis

                if (i === 0) {
                    ctx.moveTo(canvasX, canvasY);
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            }
            ctx.stroke();
        }

        // --- Main Application Logic & Event Handlers ---

        async function handleGenerateClick() {
            const inputStr = textInput.value;
            if (!inputStr) {
                statusLabel.textContent = 'Status: Please enter a string.';
                return;
            }

            // Disable UI elements and show processing status
            generateButton.disabled = true;
            downloadButton.disabled = true;
            statusLabel.textContent = `Status: Hashing "${inputStr}"...`;
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear previous plot
            
            try {
                // Use requestAnimationFrame to allow UI to update before heavy work
                await new Promise(resolve => requestAnimationFrame(resolve));

                const date = await stringToDate(inputStr);
                statusLabel.textContent = `Status: Date is M=${date.m}, D=${date.d}, Y=${date.y}. Calculating sum...`;
                await new Promise(resolve => requestAnimationFrame(resolve));

                const points = calculateExponentialSum(date.m, date.d, date.y);
                statusLabel.textContent = `Status: Plotting ${points.length.toLocaleString()} points...`;
                await new Promise(resolve => requestAnimationFrame(resolve));

                drawPlot(points);
                statusLabel.textContent = `Status: Plot generated for date ${date.d.toString().padStart(2, '0')}-${date.m.toString().padStart(2, '0')}-${date.y}`;
                downloadButton.disabled = false;

            } catch (error) {
                statusLabel.textContent = `Status: Error! ${error.message}`;
                alert(`An error occurred: ${error.message}`);
            } finally {
                generateButton.disabled = false;
            }
        }

        function handleDownloadClick() {
            const link = document.createElement('a');
            const filename = (textInput.value.replace(/[^a-z0-9]/gi, '_') || 'plot') + '.png';
            link.download = filename;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // --- Attach Event Listeners ---
        generateButton.addEventListener('click', handleGenerateClick);
        downloadButton.addEventListener('click', handleDownloadClick);
        textInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                handleGenerateClick();
            }
        });

    </script>
</body>
</html>
